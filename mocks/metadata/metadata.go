/*
 *     Copyright 2025 The Dragonfly Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by mockery. DO NOT EDIT.

package metadata

import (
	context "context"

	metadata "d7y.io/snapshotter/internal/metadata"
	mock "github.com/stretchr/testify/mock"
)

// Metadata is an autogenerated mock type for the Metadata type
type Metadata struct {
	mock.Mock
}

type Metadata_Expecter struct {
	mock *mock.Mock
}

func (_m *Metadata) EXPECT() *Metadata_Expecter {
	return &Metadata_Expecter{mock: &_m.Mock}
}

// GetContent provides a mock function with given fields: ctx, key
func (_m *Metadata) GetContent(ctx context.Context, key string) (*metadata.File, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetContent")
	}

	var r0 *metadata.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*metadata.File, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *metadata.File); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*metadata.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Metadata_GetContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContent'
type Metadata_GetContent_Call struct {
	*mock.Call
}

// GetContent is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *Metadata_Expecter) GetContent(ctx interface{}, key interface{}) *Metadata_GetContent_Call {
	return &Metadata_GetContent_Call{Call: _e.mock.On("GetContent", ctx, key)}
}

func (_c *Metadata_GetContent_Call) Run(run func(ctx context.Context, key string)) *Metadata_GetContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Metadata_GetContent_Call) Return(_a0 *metadata.File, _a1 error) *Metadata_GetContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Metadata_GetContent_Call) RunAndReturn(run func(context.Context, string) (*metadata.File, error)) *Metadata_GetContent_Call {
	_c.Call.Return(run)
	return _c
}

// GetContentMetadata provides a mock function with given fields: ctx, key
func (_m *Metadata) GetContentMetadata(ctx context.Context, key string) (*metadata.ContentMetadataEntry, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetContentMetadata")
	}

	var r0 *metadata.ContentMetadataEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*metadata.ContentMetadataEntry, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *metadata.ContentMetadataEntry); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*metadata.ContentMetadataEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Metadata_GetContentMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContentMetadata'
type Metadata_GetContentMetadata_Call struct {
	*mock.Call
}

// GetContentMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *Metadata_Expecter) GetContentMetadata(ctx interface{}, key interface{}) *Metadata_GetContentMetadata_Call {
	return &Metadata_GetContentMetadata_Call{Call: _e.mock.On("GetContentMetadata", ctx, key)}
}

func (_c *Metadata_GetContentMetadata_Call) Run(run func(ctx context.Context, key string)) *Metadata_GetContentMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Metadata_GetContentMetadata_Call) Return(_a0 *metadata.ContentMetadataEntry, _a1 error) *Metadata_GetContentMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Metadata_GetContentMetadata_Call) RunAndReturn(run func(context.Context, string) (*metadata.ContentMetadataEntry, error)) *Metadata_GetContentMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetadata provides a mock function with given fields: ctx, key
func (_m *Metadata) GetMetadata(ctx context.Context, key string) (*metadata.MetadataEntry, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetMetadata")
	}

	var r0 *metadata.MetadataEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*metadata.MetadataEntry, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *metadata.MetadataEntry); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*metadata.MetadataEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Metadata_GetMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetadata'
type Metadata_GetMetadata_Call struct {
	*mock.Call
}

// GetMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *Metadata_Expecter) GetMetadata(ctx interface{}, key interface{}) *Metadata_GetMetadata_Call {
	return &Metadata_GetMetadata_Call{Call: _e.mock.On("GetMetadata", ctx, key)}
}

func (_c *Metadata_GetMetadata_Call) Run(run func(ctx context.Context, key string)) *Metadata_GetMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Metadata_GetMetadata_Call) Return(_a0 *metadata.MetadataEntry, _a1 error) *Metadata_GetMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Metadata_GetMetadata_Call) RunAndReturn(run func(context.Context, string) (*metadata.MetadataEntry, error)) *Metadata_GetMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// IterateMetadata provides a mock function with given fields: ctx, fn
func (_m *Metadata) IterateMetadata(ctx context.Context, fn func(string, metadata.MetadataEntry) error) error {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for IterateMetadata")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, func(string, metadata.MetadataEntry) error) error); ok {
		r0 = rf(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Metadata_IterateMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IterateMetadata'
type Metadata_IterateMetadata_Call struct {
	*mock.Call
}

// IterateMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(string , metadata.MetadataEntry) error
func (_e *Metadata_Expecter) IterateMetadata(ctx interface{}, fn interface{}) *Metadata_IterateMetadata_Call {
	return &Metadata_IterateMetadata_Call{Call: _e.mock.On("IterateMetadata", ctx, fn)}
}

func (_c *Metadata_IterateMetadata_Call) Run(run func(ctx context.Context, fn func(string, metadata.MetadataEntry) error)) *Metadata_IterateMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(string, metadata.MetadataEntry) error))
	})
	return _c
}

func (_c *Metadata_IterateMetadata_Call) Return(_a0 error) *Metadata_IterateMetadata_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Metadata_IterateMetadata_Call) RunAndReturn(run func(context.Context, func(string, metadata.MetadataEntry) error) error) *Metadata_IterateMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// Prune provides a mock function with given fields: ctx, key
func (_m *Metadata) Prune(ctx context.Context, key string) ([]metadata.File, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Prune")
	}

	var r0 []metadata.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]metadata.File, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []metadata.File); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]metadata.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Metadata_Prune_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Prune'
type Metadata_Prune_Call struct {
	*mock.Call
}

// Prune is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *Metadata_Expecter) Prune(ctx interface{}, key interface{}) *Metadata_Prune_Call {
	return &Metadata_Prune_Call{Call: _e.mock.On("Prune", ctx, key)}
}

func (_c *Metadata_Prune_Call) Run(run func(ctx context.Context, key string)) *Metadata_Prune_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Metadata_Prune_Call) Return(_a0 []metadata.File, _a1 error) *Metadata_Prune_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Metadata_Prune_Call) RunAndReturn(run func(context.Context, string) ([]metadata.File, error)) *Metadata_Prune_Call {
	_c.Call.Return(run)
	return _c
}

// PutContent provides a mock function with given fields: ctx, key, file
func (_m *Metadata) PutContent(ctx context.Context, key string, file metadata.File) error {
	ret := _m.Called(ctx, key, file)

	if len(ret) == 0 {
		panic("no return value specified for PutContent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, metadata.File) error); ok {
		r0 = rf(ctx, key, file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Metadata_PutContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutContent'
type Metadata_PutContent_Call struct {
	*mock.Call
}

// PutContent is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - file metadata.File
func (_e *Metadata_Expecter) PutContent(ctx interface{}, key interface{}, file interface{}) *Metadata_PutContent_Call {
	return &Metadata_PutContent_Call{Call: _e.mock.On("PutContent", ctx, key, file)}
}

func (_c *Metadata_PutContent_Call) Run(run func(ctx context.Context, key string, file metadata.File)) *Metadata_PutContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(metadata.File))
	})
	return _c
}

func (_c *Metadata_PutContent_Call) Return(_a0 error) *Metadata_PutContent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Metadata_PutContent_Call) RunAndReturn(run func(context.Context, string, metadata.File) error) *Metadata_PutContent_Call {
	_c.Call.Return(run)
	return _c
}

// PutContentMetadata provides a mock function with given fields: ctx, metadataKey, metadataEntry
func (_m *Metadata) PutContentMetadata(ctx context.Context, metadataKey string, metadataEntry metadata.MetadataEntry) error {
	ret := _m.Called(ctx, metadataKey, metadataEntry)

	if len(ret) == 0 {
		panic("no return value specified for PutContentMetadata")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, metadata.MetadataEntry) error); ok {
		r0 = rf(ctx, metadataKey, metadataEntry)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Metadata_PutContentMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutContentMetadata'
type Metadata_PutContentMetadata_Call struct {
	*mock.Call
}

// PutContentMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - metadataKey string
//   - metadataEntry metadata.MetadataEntry
func (_e *Metadata_Expecter) PutContentMetadata(ctx interface{}, metadataKey interface{}, metadataEntry interface{}) *Metadata_PutContentMetadata_Call {
	return &Metadata_PutContentMetadata_Call{Call: _e.mock.On("PutContentMetadata", ctx, metadataKey, metadataEntry)}
}

func (_c *Metadata_PutContentMetadata_Call) Run(run func(ctx context.Context, metadataKey string, metadataEntry metadata.MetadataEntry)) *Metadata_PutContentMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(metadata.MetadataEntry))
	})
	return _c
}

func (_c *Metadata_PutContentMetadata_Call) Return(_a0 error) *Metadata_PutContentMetadata_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Metadata_PutContentMetadata_Call) RunAndReturn(run func(context.Context, string, metadata.MetadataEntry) error) *Metadata_PutContentMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// PutMetadata provides a mock function with given fields: ctx, key, entry
func (_m *Metadata) PutMetadata(ctx context.Context, key string, entry metadata.MetadataEntry) error {
	ret := _m.Called(ctx, key, entry)

	if len(ret) == 0 {
		panic("no return value specified for PutMetadata")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, metadata.MetadataEntry) error); ok {
		r0 = rf(ctx, key, entry)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Metadata_PutMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutMetadata'
type Metadata_PutMetadata_Call struct {
	*mock.Call
}

// PutMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - entry metadata.MetadataEntry
func (_e *Metadata_Expecter) PutMetadata(ctx interface{}, key interface{}, entry interface{}) *Metadata_PutMetadata_Call {
	return &Metadata_PutMetadata_Call{Call: _e.mock.On("PutMetadata", ctx, key, entry)}
}

func (_c *Metadata_PutMetadata_Call) Run(run func(ctx context.Context, key string, entry metadata.MetadataEntry)) *Metadata_PutMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(metadata.MetadataEntry))
	})
	return _c
}

func (_c *Metadata_PutMetadata_Call) Return(_a0 error) *Metadata_PutMetadata_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Metadata_PutMetadata_Call) RunAndReturn(run func(context.Context, string, metadata.MetadataEntry) error) *Metadata_PutMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// TouchMetadata provides a mock function with given fields: ctx, key
func (_m *Metadata) TouchMetadata(ctx context.Context, key string) error {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TouchMetadata")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Metadata_TouchMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TouchMetadata'
type Metadata_TouchMetadata_Call struct {
	*mock.Call
}

// TouchMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *Metadata_Expecter) TouchMetadata(ctx interface{}, key interface{}) *Metadata_TouchMetadata_Call {
	return &Metadata_TouchMetadata_Call{Call: _e.mock.On("TouchMetadata", ctx, key)}
}

func (_c *Metadata_TouchMetadata_Call) Run(run func(ctx context.Context, key string)) *Metadata_TouchMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Metadata_TouchMetadata_Call) Return(_a0 error) *Metadata_TouchMetadata_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Metadata_TouchMetadata_Call) RunAndReturn(run func(context.Context, string) error) *Metadata_TouchMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// NewMetadata creates a new instance of Metadata. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMetadata(t interface {
	mock.TestingT
	Cleanup(func())
}) *Metadata {
	mock := &Metadata{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
